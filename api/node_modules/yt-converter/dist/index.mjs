var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/utils/video.ts
import ytdl from "@distube/ytdl-core";
import path from "path";
import ffmpeg from "ffmpeg-static";
import cp from "child_process";

// src/utils/parserTitles.ts
var parserTitles = (title) => {
  const regex = /[\\,:,?,|,Â¿,*,<,>,",/]/g;
  return title.replace(regex, "");
};
var parserTitles_default = parserTitles;

// src/utils/fileExist.ts
import fs from "fs";
var fileExist = (pathname) => fs.existsSync(pathname);
var fileExist_default = fileExist;

// src/utils/video.ts
function Video(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      audio: {
        total: null,
        downloaded: null
      },
      video: {
        total: null,
        downloaded: null
      }
    };
    const videoInfo = yield ytdl.getInfo(url);
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const audio = ytdl(url, {
      filter: "audioonly",
      quality: "lowestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.audio = { downloaded, total };
    });
    const video = ytdl(url, {
      quality: (format == null ? void 0 : format.itag) || "highestvideo",
      dlChunkSize: 1024 * 1024 * 1024
    }).on("progress", (_, downloaded, total) => {
      tracker.video = { downloaded, total };
    });
    const pathname = path.resolve(process.cwd(), directory, `${fileTitle}.mp4`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = cp.spawn(ffmpegPath || ffmpeg, [
          "-loglevel",
          "8",
          "-hide_banner",
          "-progress",
          "pipe:3",
          "-i",
          "pipe:4",
          "-i",
          "pipe:5",
          "-map",
          "0:a",
          "-map",
          "1:v",
          "-c:v",
          "copy",
          `${pathname}`
        ], {
          windowsHide: true,
          stdio: [
            "inherit",
            "inherit",
            "inherit",
            "pipe",
            "pipe",
            "pipe"
          ]
        });
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const videoTotal = tracker.video.downloaded / tracker.video.total * 100;
          const audioTotal = tracker.audio.downloaded / tracker.audio.total * 100;
          const total = (videoTotal + audioTotal) / 2;
          const videoSize = tracker.video.total + tracker.audio.total;
          if (onDownloading) onDownloading({ percentage: total, size: videoSize });
        });
        ffmpegProcess.on("close", () => {
          resolve({
            message: `File in ${pathname}`,
            error: false,
            videoInfo,
            pathfile: pathname
          });
        });
        audio.pipe(ffmpegProcess.stdio[4]);
        video.pipe(ffmpegProcess.stdio[5]);
      }
    });
    return promise;
  });
}
var video_default = Video;

// src/utils/audio.ts
import ytdl2 from "@distube/ytdl-core";
import path2 from "path";
import ffmpeg2 from "ffmpeg-static";
import cp2 from "child_process";
import ffmMT from "ffmetadata";
function Audio(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      total: null,
      downloaded: null
    };
    const videoInfo = yield ytdl2.getInfo(url);
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const stream = ytdl2(url, {
      filter: "audioonly",
      quality: (format == null ? void 0 : format.itag) || "highestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.total = total;
      tracker.downloaded = downloaded;
    });
    const pathname = path2.resolve(process.cwd(), directory, `${fileTitle}.mp3`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = cp2.spawn(ffmpegPath || ffmpeg2, [
          "-loglevel",
          "8",
          "-hide_banner",
          "-progress",
          "pipe:3",
          "-i",
          "pipe:4",
          `${pathname}`
        ], {
          windowsHide: true,
          stdio: [
            "inherit",
            "inherit",
            "inherit",
            "pipe",
            "pipe",
            "pipe"
          ]
        });
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const percentage = tracker.downloaded / tracker.total * 100;
          const size = tracker.total;
          if (onDownloading) onDownloading({ percentage, size });
        });
        ffmpegProcess.on("close", () => {
          const metadata = {
            artist: videoInfo.videoDetails.author.name,
            title: fileTitle,
            album: videoInfo.videoDetails.author.name
          };
          ffmMT.write(pathname, metadata, (err) => {
            if (err) throw err;
            resolve({
              message: `File in ${pathname}`,
              error: false,
              videoInfo,
              pathfile: pathname
            });
          });
        });
        stream.pipe(ffmpegProcess.stdio[4]);
      }
    });
    return promise;
  });
}
var audio_default = Audio;
export {
  audio_default as Audio,
  video_default as Video
};
//# sourceMappingURL=index.mjs.map