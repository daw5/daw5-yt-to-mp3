var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Audio: () => audio_default,
  Video: () => video_default
});
module.exports = __toCommonJS(src_exports);

// src/utils/video.ts
var import_ytdl_core = __toESM(require("@distube/ytdl-core"));
var import_path = __toESM(require("path"));
var import_ffmpeg_static = __toESM(require("ffmpeg-static"));
var import_child_process = __toESM(require("child_process"));

// src/utils/parserTitles.ts
var parserTitles = (title) => {
  const regex = /[\\,:,?,|,Â¿,*,<,>,",/]/g;
  return title.replace(regex, "");
};
var parserTitles_default = parserTitles;

// src/utils/fileExist.ts
var import_fs = __toESM(require("fs"));
var fileExist = (pathname) => import_fs.default.existsSync(pathname);
var fileExist_default = fileExist;

// src/utils/video.ts
function Video(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      audio: {
        total: null,
        downloaded: null
      },
      video: {
        total: null,
        downloaded: null
      }
    };
    const videoInfo = yield import_ytdl_core.default.getInfo(url);
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const audio = (0, import_ytdl_core.default)(url, {
      filter: "audioonly",
      quality: "lowestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.audio = { downloaded, total };
    });
    const video = (0, import_ytdl_core.default)(url, {
      quality: (format == null ? void 0 : format.itag) || "highestvideo",
      dlChunkSize: 1024 * 1024 * 1024
    }).on("progress", (_, downloaded, total) => {
      tracker.video = { downloaded, total };
    });
    const pathname = import_path.default.resolve(process.cwd(), directory, `${fileTitle}.mp4`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = import_child_process.default.spawn(ffmpegPath || import_ffmpeg_static.default, [
          "-loglevel",
          "8",
          "-hide_banner",
          "-progress",
          "pipe:3",
          "-i",
          "pipe:4",
          "-i",
          "pipe:5",
          "-map",
          "0:a",
          "-map",
          "1:v",
          "-c:v",
          "copy",
          `${pathname}`
        ], {
          windowsHide: true,
          stdio: [
            "inherit",
            "inherit",
            "inherit",
            "pipe",
            "pipe",
            "pipe"
          ]
        });
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const videoTotal = tracker.video.downloaded / tracker.video.total * 100;
          const audioTotal = tracker.audio.downloaded / tracker.audio.total * 100;
          const total = (videoTotal + audioTotal) / 2;
          const videoSize = tracker.video.total + tracker.audio.total;
          if (onDownloading) onDownloading({ percentage: total, size: videoSize });
        });
        ffmpegProcess.on("close", () => {
          resolve({
            message: `File in ${pathname}`,
            error: false,
            videoInfo,
            pathfile: pathname
          });
        });
        audio.pipe(ffmpegProcess.stdio[4]);
        video.pipe(ffmpegProcess.stdio[5]);
      }
    });
    return promise;
  });
}
var video_default = Video;

// src/utils/audio.ts
var import_ytdl_core2 = __toESM(require("@distube/ytdl-core"));
var import_path2 = __toESM(require("path"));
var import_ffmpeg_static2 = __toESM(require("ffmpeg-static"));
var import_child_process2 = __toESM(require("child_process"));
var import_ffmetadata = __toESM(require("ffmetadata"));
function Audio(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      total: null,
      downloaded: null
    };
    const videoInfo = yield import_ytdl_core2.default.getInfo(url);
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const stream = (0, import_ytdl_core2.default)(url, {
      filter: "audioonly",
      quality: (format == null ? void 0 : format.itag) || "highestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.total = total;
      tracker.downloaded = downloaded;
    });
    const pathname = import_path2.default.resolve(process.cwd(), directory, `${fileTitle}.mp3`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = import_child_process2.default.spawn(ffmpegPath || import_ffmpeg_static2.default, [
          "-loglevel",
          "8",
          "-hide_banner",
          "-progress",
          "pipe:3",
          "-i",
          "pipe:4",
          `${pathname}`
        ], {
          windowsHide: true,
          stdio: [
            "inherit",
            "inherit",
            "inherit",
            "pipe",
            "pipe",
            "pipe"
          ]
        });
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const percentage = tracker.downloaded / tracker.total * 100;
          const size = tracker.total;
          if (onDownloading) onDownloading({ percentage, size });
        });
        ffmpegProcess.on("close", () => {
          const metadata = {
            artist: videoInfo.videoDetails.author.name,
            title: fileTitle,
            album: videoInfo.videoDetails.author.name
          };
          import_ffmetadata.default.write(pathname, metadata, (err) => {
            if (err) throw err;
            resolve({
              message: `File in ${pathname}`,
              error: false,
              videoInfo,
              pathfile: pathname
            });
          });
        });
        stream.pipe(ffmpegProcess.stdio[4]);
      }
    });
    return promise;
  });
}
var audio_default = Audio;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Audio,
  Video
});
//# sourceMappingURL=index.js.map